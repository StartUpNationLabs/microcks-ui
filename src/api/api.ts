/* tslint:disable */
/* eslint-disable */
/**
 * Microcks API v1.9
 * API offered by Microcks, the Kubernetes native tool for API and microservices mocking and testing (microcks.io)
 *
 * The version of the OpenAPI document: 1.9.0
 * Contact: laurent@microcks.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Abstract bean representing a Service or API Exchange.
 * @export
 * @interface AbstractExchange
 */
export interface AbstractExchange {
    /**
     * Discriminant type for identifying kind of exchange
     * @type {string}
     * @memberof AbstractExchange
     */
    'type': AbstractExchangeTypeEnum;
}

export const AbstractExchangeTypeEnum = {
    ReqRespPair: 'reqRespPair',
    UnidirEvent: 'unidirEvent'
} as const;

export type AbstractExchangeTypeEnum = typeof AbstractExchangeTypeEnum[keyof typeof AbstractExchangeTypeEnum];

/**
 * Protocol binding details for asynchronous operations
 * @export
 * @interface Binding
 */
export interface Binding {
    /**
     * Protocol binding identifier
     * @type {string}
     * @memberof Binding
     */
    'type': BindingTypeEnum;
    /**
     * Type of key for Kafka messages
     * @type {string}
     * @memberof Binding
     */
    'keyType'?: string;
    /**
     * Type of destination for asynchronous messages of this operation
     * @type {string}
     * @memberof Binding
     */
    'destinationType'?: string;
    /**
     * Name of destination for asynchronous messages of this operation
     * @type {string}
     * @memberof Binding
     */
    'destinationName': string;
    /**
     * Quality of Service attribute for MQTT binding
     * @type {string}
     * @memberof Binding
     */
    'qoS'?: string;
    /**
     * Persistent attribute for MQTT binding
     * @type {boolean}
     * @memberof Binding
     */
    'persistent'?: boolean;
    /**
     * HTTP method for WebSocket binding
     * @type {string}
     * @memberof Binding
     */
    'method'?: string;
}

export const BindingTypeEnum = {
    Kafka: 'KAFKA',
    Mqtt: 'MQTT',
    Ws: 'WS',
    Amqp: 'AMQP',
    Nats: 'NATS',
    Googlepubsub: 'GOOGLEPUBSUB'
} as const;

export type BindingTypeEnum = typeof BindingTypeEnum[keyof typeof BindingTypeEnum];

/**
 * A simple Counter type.
 * @export
 * @interface Counter
 */
export interface Counter {
    /**
     * Number of items in a resource collection
     * @type {number}
     * @memberof Counter
     */
    'counter'?: number;
}
/**
 * The daily statistic of a service mock invocations
 * @export
 * @interface DailyInvocationStatistic
 */
export interface DailyInvocationStatistic {
    /**
     * Unique identifier of this statistic object
     * @type {string}
     * @memberof DailyInvocationStatistic
     */
    'id': string;
    /**
     * The day (formatted as yyyyMMdd string) represented by this statistic
     * @type {string}
     * @memberof DailyInvocationStatistic
     */
    'day': string;
    /**
     * The name of the service this statistic is related to
     * @type {string}
     * @memberof DailyInvocationStatistic
     */
    'serviceName': string;
    /**
     * The version of the service this statistic is related to
     * @type {string}
     * @memberof DailyInvocationStatistic
     */
    'serviceVersion': string;
    /**
     * The number of service mock invocations on this day
     * @type {number}
     * @memberof DailyInvocationStatistic
     */
    'dailyCount': number;
    /**
     * The number of service mock invocations per hour of the day (keys range from 0 to 23)
     * @type {{ [key: string]: any; }}
     * @memberof DailyInvocationStatistic
     */
    'hourlyCount'?: { [key: string]: any; };
    /**
     * The number of service mock invocations per minute of the day (keys range from 0 to 1439)
     * @type {{ [key: string]: any; }}
     * @memberof DailyInvocationStatistic
     */
    'minuteCount'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface EventMessage
 */
export interface EventMessage {
    /**
     * Unique identifier of this message
     * @type {string}
     * @memberof EventMessage
     */
    'id': string;
    /**
     * Content type of message
     * @type {string}
     * @memberof EventMessage
     */
    'mediaType': string;
    /**
     * Unique distinct name of this message
     * @type {string}
     * @memberof EventMessage
     */
    'name'?: string;
    /**
     * Body content for this message
     * @type {string}
     * @memberof EventMessage
     */
    'content'?: string;
    /**
     * Identifier of Operation this message is associated to
     * @type {string}
     * @memberof EventMessage
     */
    'operationId'?: string;
    /**
     * Unique identifier of TestCase this message is attached (in case of a test)
     * @type {string}
     * @memberof EventMessage
     */
    'testCaseId'?: string;
    /**
     * Headers for this message
     * @type {Array<Header>}
     * @memberof EventMessage
     */
    'headers'?: Array<Header>;
}
/**
 * @type Exchange
 * Abstract representation of a Service or API exchange type (request/response, event based, ...)
 * @export
 */
export type Exchange = { type: 'reqRespPair' } & RequestResponsePair | { type: 'unidirEvent' } & UnidirectionalEvent;

/**
 * Representation of optional features configuration used by Microcks server
 * @export
 * @interface FeaturesConfig
 */
export interface FeaturesConfig {
    [key: string]: any;

    /**
     * 
     * @type {FeaturesConfigRepositoryFilter}
     * @memberof FeaturesConfig
     */
    'repository-filter'?: FeaturesConfigRepositoryFilter;
    /**
     * 
     * @type {FeaturesConfigMicrocksHub}
     * @memberof FeaturesConfig
     */
    'microcks-hub'?: FeaturesConfigMicrocksHub;
    /**
     * 
     * @type {FeaturesConfigRepositoryTenancy}
     * @memberof FeaturesConfig
     */
    'repository-tenancy'?: FeaturesConfigRepositoryTenancy;
    /**
     * 
     * @type {FeaturesConfigAsyncApi}
     * @memberof FeaturesConfig
     */
    'async-api'?: FeaturesConfigAsyncApi;
}
/**
 * Asynchronous feature properties
 * @export
 * @interface FeaturesConfigAsyncApi
 */
export interface FeaturesConfigAsyncApi {
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigAsyncApi
     */
    'default-binding'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigAsyncApi
     */
    'endpoint-MQTT'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigAsyncApi
     */
    'endpoint-WS'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigAsyncApi
     */
    'endpoint-KAFKA'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigAsyncApi
     */
    'endpoint-AMQP'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigAsyncApi
     */
    'endpoint-NATS'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigAsyncApi
     */
    'endpoint-GOOGLEPUBSUB'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigAsyncApi
     */
    'enabled'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigAsyncApi
     */
    'frequencies'?: string;
}
/**
 * Microcks Hub feature properties
 * @export
 * @interface FeaturesConfigMicrocksHub
 */
export interface FeaturesConfigMicrocksHub {
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigMicrocksHub
     */
    'allowed-roles'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigMicrocksHub
     */
    'endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigMicrocksHub
     */
    'enabled'?: string;
}
/**
 * Repository filtering feature properties
 * @export
 * @interface FeaturesConfigRepositoryFilter
 */
export interface FeaturesConfigRepositoryFilter {
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigRepositoryFilter
     */
    'label-label'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigRepositoryFilter
     */
    'enabled'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigRepositoryFilter
     */
    'label-list'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigRepositoryFilter
     */
    'label-key'?: string;
}
/**
 * Repository tenancy feature properties
 * @export
 * @interface FeaturesConfigRepositoryTenancy
 */
export interface FeaturesConfigRepositoryTenancy {
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigRepositoryTenancy
     */
    'enabled'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeaturesConfigRepositoryTenancy
     */
    'artifact-import-allowed-roles'?: string;
}
/**
 * @type GetService200Response
 * @export
 */
export type GetService200Response = Service | ServiceView;

/**
 * Transport headers for both Requests and Responses
 * @export
 * @interface Header
 */
export interface Header {
    /**
     * Unique distinct name of this Header
     * @type {string}
     * @memberof Header
     */
    'name': string;
    /**
     * Values for this Header
     * @type {Array<string>}
     * @memberof Header
     */
    'values': Array<string>;
}
/**
 * Data Transfert Object for headers of both Requests and Responses
 * @export
 * @interface HeaderDTO
 */
export interface HeaderDTO {
    /**
     * Unique distinct name of this Header
     * @type {string}
     * @memberof HeaderDTO
     */
    'name': string;
    /**
     * Values for this header (comma separated strings)
     * @type {string}
     * @memberof HeaderDTO
     */
    'values': string;
}
/**
 * An ImportJob allow defining a repository artifact to poll for discovering Services and APIs mocks and tests
 * @export
 * @interface ImportJob
 */
export interface ImportJob {
    /**
     * Unique identifier of ImportJob
     * @type {string}
     * @memberof ImportJob
     */
    'id'?: string;
    /**
     * Unique distinct name of this ImportJob
     * @type {string}
     * @memberof ImportJob
     */
    'name': string;
    /**
     * URL of mocks and tests repository artifact
     * @type {string}
     * @memberof ImportJob
     */
    'repositoryUrl': string;
    /**
     * Whether to disable SSL certificate verification when checking repository
     * @type {boolean}
     * @memberof ImportJob
     */
    'repositoryDisableSSLValidation'?: boolean;
    /**
     * Reserved for future usage
     * @type {string}
     * @memberof ImportJob
     */
    'frequency'?: string;
    /**
     * Creation date for this ImportJob
     * @type {string}
     * @memberof ImportJob
     */
    'createdDate'?: string;
    /**
     * Date last import was done
     * @type {string}
     * @memberof ImportJob
     */
    'lastImportDate'?: string;
    /**
     * Error message of last import (if any)
     * @type {string}
     * @memberof ImportJob
     */
    'lastImportError'?: string;
    /**
     * Whether this ImportJob is active (ie. scheduled for execution)
     * @type {boolean}
     * @memberof ImportJob
     */
    'active'?: boolean;
    /**
     * Etag of repository URL during previous import. Is used for not re-importing if no recent changes
     * @type {string}
     * @memberof ImportJob
     */
    'etag'?: string;
    /**
     * References of Services discovered when checking repository
     * @type {Array<ServiceRef>}
     * @memberof ImportJob
     */
    'serviceRefs'?: Array<ServiceRef>;
    /**
     * 
     * @type {Metadata}
     * @memberof ImportJob
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {SecretRef}
     * @memberof ImportJob
     */
    'secretRef'?: SecretRef;
    /**
     * Flag telling if considered as primary or secondary artifact. Default to `true`
     * @type {boolean}
     * @memberof ImportJob
     */
    'mainArtifact'?: boolean;
}
/**
 * Representation of Keycloak / SSO configuration used by Microcks server
 * @export
 * @interface KeycloakConfig
 */
export interface KeycloakConfig {
    /**
     * Authentication realm name
     * @type {string}
     * @memberof KeycloakConfig
     */
    'realm': string;
    /**
     * SSO Server authentication url
     * @type {string}
     * @memberof KeycloakConfig
     */
    'auth-server-url': string;
    /**
     * Name of public-client that can be used for requesting OAuth token
     * @type {boolean}
     * @memberof KeycloakConfig
     */
    'public-client': boolean;
    /**
     * SSL certificates requirements
     * @type {string}
     * @memberof KeycloakConfig
     */
    'ssl-required': KeycloakConfigSslRequiredEnum;
    /**
     * Name of Keycloak resource/application used on client side
     * @type {string}
     * @memberof KeycloakConfig
     */
    'resource': string;
    /**
     * Whether Keycloak authentification and usage is enabled
     * @type {boolean}
     * @memberof KeycloakConfig
     */
    'enabled': boolean;
}

export const KeycloakConfigSslRequiredEnum = {
    None: 'none',
    External: 'external'
} as const;

export type KeycloakConfigSslRequiredEnum = typeof KeycloakConfigSslRequiredEnum[keyof typeof KeycloakConfigSslRequiredEnum];

/**
 * Commodity object for holding metadata on any entity. This object is inspired by Kubernetes metadata.
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * Creation date of attached object
     * @type {number}
     * @memberof Metadata
     */
    'createdOn': number;
    /**
     * Last update of attached object
     * @type {number}
     * @memberof Metadata
     */
    'lastUpdate': number;
    /**
     * Annotations of attached object
     * @type {{ [key: string]: string; }}
     * @memberof Metadata
     */
    'annotations'?: { [key: string]: string; };
    /**
     * Labels put on attached object
     * @type {{ [key: string]: string; }}
     * @memberof Metadata
     */
    'labels'?: { [key: string]: string; };
}
/**
 * OAuth2 authorized client that performed a test
 * @export
 * @interface OAuth2AuthorizedClient
 */
export interface OAuth2AuthorizedClient {
    /**
     * 
     * @type {OAuth2GrantType}
     * @memberof OAuth2AuthorizedClient
     */
    'grantType': OAuth2GrantType;
    /**
     * Name of authorized principal (clientId or username in the case of Password grant type)
     * @type {string}
     * @memberof OAuth2AuthorizedClient
     */
    'principalName': string;
    /**
     * Identity Provider URI used for token retrieval
     * @type {string}
     * @memberof OAuth2AuthorizedClient
     */
    'tokenUri': string;
    /**
     * Included scopes (separated using space)
     * @type {string}
     * @memberof OAuth2AuthorizedClient
     */
    'scopes'?: string;
}


/**
 * Represents a volatile OAuth2 client context usually associated with a Test request
 * @export
 * @interface OAuth2ClientContent
 */
export interface OAuth2ClientContent {
    /**
     * Id for connecting to OAuth2 identity provider
     * @type {string}
     * @memberof OAuth2ClientContent
     */
    'clientId': string;
    /**
     * Secret for connecting to OAuth2 identity provider
     * @type {string}
     * @memberof OAuth2ClientContent
     */
    'clientSecret': string;
    /**
     * URI for retrieving an access token from OAuth2 identity provider
     * @type {string}
     * @memberof OAuth2ClientContent
     */
    'tokenUri': string;
    /**
     * Username in case you\'re using the Resource Owner Password flow
     * @type {string}
     * @memberof OAuth2ClientContent
     */
    'username'?: string;
    /**
     * User password in case you\'re suing the Resource Owner password flow
     * @type {string}
     * @memberof OAuth2ClientContent
     */
    'password'?: string;
    /**
     * Refresh token in case you\'re using the Refresh Token rotation flow
     * @type {string}
     * @memberof OAuth2ClientContent
     */
    'refreshToken'?: string;
}
/**
 * Enumeration for the different supported grants/flows of OAuth2
 * @export
 * @enum {string}
 */

export const OAuth2GrantType = {
    Password: 'PASSWORD',
    ClientCredentials: 'CLIENT_CREDENTIALS',
    RefreshToken: 'REFRESH_TOKEN'
} as const;

export type OAuth2GrantType = typeof OAuth2GrantType[keyof typeof OAuth2GrantType];


/**
 * An Operation of a Service or API
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * Unique name of this Operation within Service scope
     * @type {string}
     * @memberof Operation
     */
    'name': string;
    /**
     * Represents transport method
     * @type {string}
     * @memberof Operation
     */
    'method': string;
    /**
     * Name of input parameters in case of Xml based Service
     * @type {string}
     * @memberof Operation
     */
    'inputName'?: string;
    /**
     * Name of output parameters in case of Xml based Service
     * @type {string}
     * @memberof Operation
     */
    'outputName'?: string;
    /**
     * Dispatcher strategy used for mocks
     * @type {string}
     * @memberof Operation
     */
    'dispatcher'?: string;
    /**
     * DispatcherRules used for mocks
     * @type {string}
     * @memberof Operation
     */
    'dispatcherRules'?: string;
    /**
     * Default response time delay for mocks
     * @type {number}
     * @memberof Operation
     */
    'defaultDelay'?: number;
    /**
     * Paths the mocks endpoints are mapped on
     * @type {Array<string>}
     * @memberof Operation
     */
    'resourcePaths'?: Array<string>;
    /**
     * Contraints that may apply to mock invocatino on this operation
     * @type {Array<ParameterConstraint>}
     * @memberof Operation
     */
    'parameterContraints'?: Array<ParameterConstraint>;
    /**
     * Map of protocol binding details for this operation
     * @type {{ [key: string]: Binding; }}
     * @memberof Operation
     */
    'bindings'?: { [key: string]: Binding; };
}
/**
 * Data Transfer object for grouping the mutable properties of an Operation
 * @export
 * @interface OperationOverrideDTO
 */
export interface OperationOverrideDTO {
    /**
     * Type of dispatcher to apply for this operation
     * @type {string}
     * @memberof OperationOverrideDTO
     */
    'dispatcher'?: string;
    /**
     * Rules of dispatcher for this operation
     * @type {string}
     * @memberof OperationOverrideDTO
     */
    'dispatcherRules'?: string;
    /**
     * Default delay in milliseconds to apply to mock responses on this operation
     * @type {number}
     * @memberof OperationOverrideDTO
     */
    'defaultDelay'?: number;
    /**
     * Constraints that may apply to incoming parameters on this operation
     * @type {Array<ParameterConstraint>}
     * @memberof OperationOverrideDTO
     */
    'parameterConstraints'?: Array<ParameterConstraint>;
}
/**
 * Companion object for Operation that may be used to express constraints on request parameters
 * @export
 * @interface ParameterConstraint
 */
export interface ParameterConstraint {
    /**
     * Parameter name
     * @type {string}
     * @memberof ParameterConstraint
     */
    'name': string;
    /**
     * Whether it\'s a required constraint
     * @type {boolean}
     * @memberof ParameterConstraint
     */
    'required'?: boolean;
    /**
     * Whether it\'s a recopy constraint
     * @type {boolean}
     * @memberof ParameterConstraint
     */
    'recopy'?: boolean;
    /**
     * Whether it\'s a regular expression matching constraint
     * @type {string}
     * @memberof ParameterConstraint
     */
    'mustMatchRegexp'?: string;
    /**
     * Parameter location
     * @type {string}
     * @memberof ParameterConstraint
     */
    'in'?: ParameterConstraintInEnum;
}

export const ParameterConstraintInEnum = {
    Path: 'path',
    Query: 'query',
    Header: 'header'
} as const;

export type ParameterConstraintInEnum = typeof ParameterConstraintInEnum[keyof typeof ParameterConstraintInEnum];

/**
 * A mock invocation or test request
 * @export
 * @interface Request
 */
export interface Request {
    /**
     * Unique identifier of Request
     * @type {string}
     * @memberof Request
     */
    'id'?: string;
    /**
     * Unique distinct name of this Request
     * @type {string}
     * @memberof Request
     */
    'name': string;
    /**
     * Body content for this request
     * @type {string}
     * @memberof Request
     */
    'content'?: string;
    /**
     * Identifier of Operation this Request is associated to
     * @type {string}
     * @memberof Request
     */
    'operationId': string;
    /**
     * Unique identifier of TestCase this Request is attached (in case of a test)
     * @type {string}
     * @memberof Request
     */
    'testCaseId'?: string;
    /**
     * Headers for this Request
     * @type {Array<Header>}
     * @memberof Request
     */
    'headers'?: Array<Header>;
}
/**
 * Request associated with corresponding Response
 * @export
 * @interface RequestResponsePair
 */
export interface RequestResponsePair {
    /**
     * Discriminant type for identifying kind of exchange
     * @type {string}
     * @memberof RequestResponsePair
     */
    'type': RequestResponsePairTypeEnum;
    /**
     * 
     * @type {Request}
     * @memberof RequestResponsePair
     */
    'request': Request;
    /**
     * 
     * @type {Response}
     * @memberof RequestResponsePair
     */
    'response': Response;
}

export const RequestResponsePairTypeEnum = {
    ReqRespPair: 'reqRespPair',
    UnidirEvent: 'unidirEvent'
} as const;

export type RequestResponsePairTypeEnum = typeof RequestResponsePairTypeEnum[keyof typeof RequestResponsePairTypeEnum];

/**
 * Resource represents a Service or API artifacts such as specification, contract
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * Uniquer identifier of this Service or API Resource
     * @type {string}
     * @memberof Resource
     */
    'id': string;
    /**
     * Unique name/business identifier for this Service or API resource
     * @type {string}
     * @memberof Resource
     */
    'name': string;
    /**
     * String content of this resource
     * @type {string}
     * @memberof Resource
     */
    'content': string;
    /**
     * 
     * @type {ResourceType}
     * @memberof Resource
     */
    'type': ResourceType;
    /**
     * Unique identifier of the Servoce or API this resource is attached to
     * @type {string}
     * @memberof Resource
     */
    'serviceId': string;
    /**
     * Relative path of this resource regarding main resource
     * @type {string}
     * @memberof Resource
     */
    'path'?: string;
    /**
     * Short name of the artifact this resource was extracted from
     * @type {string}
     * @memberof Resource
     */
    'sourceArtifact'?: string;
}


/**
 * Types of managed resources for Services or APIs
 * @export
 * @enum {string}
 */

export const ResourceType = {
    Wsdl: 'WSDL',
    Xsd: 'XSD',
    JsonSchema: 'JSON_SCHEMA',
    OpenApiSpec: 'OPEN_API_SPEC',
    OpenApiSchema: 'OPEN_API_SCHEMA',
    AsyncApiSpec: 'ASYNC_API_SPEC',
    AsyncApiSchema: 'ASYNC_API_SCHEMA',
    AvroSchema: 'AVRO_SCHEMA',
    ProtobufSchema: 'PROTOBUF_SCHEMA',
    ProtobufDescription: 'PROTOBUF_DESCRIPTION',
    GraphqlSchema: 'GRAPHQL_SCHEMA',
    PostmanCollection: 'POSTMAN_COLLECTION'
} as const;

export type ResourceType = typeof ResourceType[keyof typeof ResourceType];


/**
 * A mock invocation or test response
 * @export
 * @interface Response
 */
export interface Response {
    /**
     * Identifier of Operation this Response is associated to
     * @type {string}
     * @memberof Response
     */
    'operationId': string;
    /**
     * Body content of this Response
     * @type {string}
     * @memberof Response
     */
    'content'?: string;
    /**
     * Unique identifier of Response
     * @type {string}
     * @memberof Response
     */
    'id'?: string;
    /**
     * Unique distinct name of this Response
     * @type {string}
     * @memberof Response
     */
    'name': string;
    /**
     * Unique identifier of TestCase this Response is attached (in case of a test)
     * @type {string}
     * @memberof Response
     */
    'testCaseId'?: string;
    /**
     * Headers for this Response
     * @type {Array<Header>}
     * @memberof Response
     */
    'headers'?: Array<Header>;
}
/**
 * A Secret allows grouping informations on how to access a restricted resource such as a repsoitory URL. Secrets are typically used by ImpoortJobs.
 * @export
 * @interface Secret
 */
export interface Secret {
    /**
     * Unique identifier of Secret
     * @type {string}
     * @memberof Secret
     */
    'id'?: string;
    /**
     * Unique distinct name of Secret
     * @type {string}
     * @memberof Secret
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'tokenHeader'?: string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'caCertPem'?: string;
    /**
     * Description of this Secret
     * @type {string}
     * @memberof Secret
     */
    'description': string;
}
/**
 * Lightweight reference for an existing Secret
 * @export
 * @interface SecretRef
 */
export interface SecretRef {
    /**
     * Unique identifier or referenced Secret
     * @type {string}
     * @memberof SecretRef
     */
    'secretId': string;
    /**
     * Distinct name of the referenced Secret
     * @type {string}
     * @memberof SecretRef
     */
    'name': string;
}
/**
 * Represents a Service or API definition as registred into Microcks repository
 * @export
 * @interface Service
 */
export interface Service {
    /**
     * Unique identifier for this Service or API
     * @type {string}
     * @memberof Service
     */
    'id'?: string;
    /**
     * Distinct name for this Service or API (maybe shared among many versions)
     * @type {string}
     * @memberof Service
     */
    'name': string;
    /**
     * Distinct version for a named Service or API
     * @type {string}
     * @memberof Service
     */
    'version': string;
    /**
     * Service or API Type
     * @type {string}
     * @memberof Service
     */
    'type': ServiceTypeEnum;
    /**
     * Set of Operations for Service or API
     * @type {Array<Operation>}
     * @memberof Service
     */
    'operations'?: Array<Operation>;
    /**
     * Associated Xml Namespace in case of Xml based Service
     * @type {string}
     * @memberof Service
     */
    'xmlNS'?: string;
    /**
     * 
     * @type {Metadata}
     * @memberof Service
     */
    'metadata'?: Metadata;
    /**
     * Short name of the main/primary artifact this service was created from
     * @type {string}
     * @memberof Service
     */
    'sourceArtifact': string;
}

export const ServiceTypeEnum = {
    Rest: 'REST',
    SoapHttp: 'SOAP_HTTP',
    GenericRest: 'GENERIC_REST',
    GenericEvent: 'GENERIC_EVENT',
    Event: 'EVENT',
    Grpc: 'GRPC',
    Graphql: 'GRAPHQL'
} as const;

export type ServiceTypeEnum = typeof ServiceTypeEnum[keyof typeof ServiceTypeEnum];

/**
 * Lightweight reference of an existing Service
 * @export
 * @interface ServiceRef
 */
export interface ServiceRef {
    /**
     * Unique reference of a Service
     * @type {string}
     * @memberof ServiceRef
     */
    'serviceId': string;
    /**
     * The Service name
     * @type {string}
     * @memberof ServiceRef
     */
    'name': string;
    /**
     * The Service version
     * @type {string}
     * @memberof ServiceRef
     */
    'version': string;
}
/**
 * Aggregate bean for grouping a Service an its messages pairs
 * @export
 * @interface ServiceView
 */
export interface ServiceView {
    /**
     * 
     * @type {Service}
     * @memberof ServiceView
     */
    'service': Service;
    /**
     * Map of messages for this Service. Keys are operation name, values are array of messages for this operation
     * @type {{ [key: string]: Array<Exchange>; }}
     * @memberof ServiceView
     */
    'messagesMap': { [key: string]: Array<Exchange>; };
}
/**
 * Companion objects for TestResult. Each TestCaseResult correspond to a particuliar service operation / action reference by the operationName field. TestCaseResults owns a collection of TestStepResults (one for every request associated to service operation / action).
 * @export
 * @interface TestCaseResult
 */
export interface TestCaseResult {
    /**
     * Flag telling if test case is a success
     * @type {boolean}
     * @memberof TestCaseResult
     */
    'success': boolean;
    /**
     * Elapsed time in milliseconds since the test case beginning
     * @type {number}
     * @memberof TestCaseResult
     */
    'elapsedTime': number;
    /**
     * Name of operation this test case is bound to
     * @type {string}
     * @memberof TestCaseResult
     */
    'operationName': string;
    /**
     * Test steps associated to this test case
     * @type {Array<TestStepResult>}
     * @memberof TestCaseResult
     */
    'testStepResults'?: Array<TestStepResult>;
}
/**
 * 
 * @export
 * @interface TestCaseReturnDTO
 */
export interface TestCaseReturnDTO {
    /**
     * Name of related operation for this TestCase
     * @type {string}
     * @memberof TestCaseReturnDTO
     */
    'operationName': string;
}
/**
 * Represents the test conformance metrics (current score, history and evolution trend) of a Service
 * @export
 * @interface TestConformanceMetric
 */
export interface TestConformanceMetric {
    /**
     * Unique identifier of coverage metric
     * @type {string}
     * @memberof TestConformanceMetric
     */
    'id': string;
    /**
     * Unique identifier of the Service this metric is related to
     * @type {string}
     * @memberof TestConformanceMetric
     */
    'serviceId': string;
    /**
     * Value of the label used for metrics aggregation (if any)
     * @type {string}
     * @memberof TestConformanceMetric
     */
    'aggregationLabelValue'?: string;
    /**
     * Maximum conformance score that can be reached (depends on samples expresiveness)
     * @type {number}
     * @memberof TestConformanceMetric
     */
    'maxPossibleScore': number;
    /**
     * Current test conformance score for the related Service
     * @type {number}
     * @memberof TestConformanceMetric
     */
    'currentScore': number;
    /**
     * The day of latest score update (in yyyyMMdd format)
     * @type {string}
     * @memberof TestConformanceMetric
     */
    'lastUpdateDay'?: string;
    /**
     * 
     * @type {Trend}
     * @memberof TestConformanceMetric
     */
    'latestTrend'?: Trend;
    /**
     * History of latest scores (key is date with format yyyyMMdd, value is score as double)
     * @type {{ [key: string]: number; }}
     * @memberof TestConformanceMetric
     */
    'latestScores'?: { [key: string]: number; };
}


/**
 * Test request is a minimalist wrapper for requesting the launch of a new test
 * @export
 * @interface TestRequest
 */
export interface TestRequest {
    /**
     * Unique identifier of service to test
     * @type {string}
     * @memberof TestRequest
     */
    'serviceId': string;
    /**
     * Endpoint to test for this service
     * @type {string}
     * @memberof TestRequest
     */
    'testEndpoint': string;
    /**
     * 
     * @type {TestRunnerType}
     * @memberof TestRequest
     */
    'runnerType': TestRunnerType;
    /**
     * The maximum time (in milliseconds) to wait for this test ends
     * @type {number}
     * @memberof TestRequest
     */
    'timeout': number;
    /**
     * A restriction on service operations to test
     * @type {Array<string>}
     * @memberof TestRequest
     */
    'filteredOperations'?: Array<string>;
    /**
     * The name of Secret to use for connecting the test endpoint
     * @type {string}
     * @memberof TestRequest
     */
    'secretName'?: string;
    /**
     * 
     * @type {OAuth2ClientContent}
     * @memberof TestRequest
     */
    'oAuth2Context'?: OAuth2ClientContent;
    /**
     * Specification of additional headers for a Service/API operations. Keys are operation name or \"globals\" (if header applies to all), values are Header objects DTO.
     * @type {{ [key: string]: Array<HeaderDTO>; }}
     * @memberof TestRequest
     */
    'operationsHeaders'?: { [key: string]: Array<HeaderDTO>; };
}


/**
 * Represents the result of a Service or API test run by Microcks. Tests are related to a service and made of multiple test cases corresponding to each operations / actions composing service. Tests are run against a specific endpoint named testedEndpoint. It holds global markers telling if test still ran, is a success, how many times is has taken and so on ...
 * @export
 * @interface TestResult
 */
export interface TestResult {
    /**
     * Unique identifier of TestResult
     * @type {string}
     * @memberof TestResult
     */
    'id': string;
    /**
     * Revision number of this test
     * @type {number}
     * @memberof TestResult
     */
    'version': number;
    /**
     * Incremental number for tracking number of tests of a service
     * @type {number}
     * @memberof TestResult
     */
    'testNumber': number;
    /**
     * Timestamp of creation date of this service
     * @type {number}
     * @memberof TestResult
     */
    'testDate': number;
    /**
     * Endpoint used during test
     * @type {string}
     * @memberof TestResult
     */
    'testedEndpoint': string;
    /**
     * Unique identifier of service tested
     * @type {string}
     * @memberof TestResult
     */
    'serviceId': string;
    /**
     * Elapsed time in milliseconds since test beginning
     * @type {number}
     * @memberof TestResult
     */
    'elapsedTime'?: number;
    /**
     * Flag telling if test is a success
     * @type {boolean}
     * @memberof TestResult
     */
    'success': boolean;
    /**
     * Flag telling is test is still in progress
     * @type {boolean}
     * @memberof TestResult
     */
    'inProgress': boolean;
    /**
     * 
     * @type {TestRunnerType}
     * @memberof TestResult
     */
    'runnerType': TestRunnerType;
    /**
     * TestCase results associated to this test
     * @type {Array<TestCaseResult>}
     * @memberof TestResult
     */
    'testCaseResults'?: Array<TestCaseResult>;
    /**
     * 
     * @type {SecretRef}
     * @memberof TestResult
     */
    'secretRef'?: SecretRef;
    /**
     * Specification of additional headers for a Service/API operations. Keys are operation name or \"globals\" (if header applies to all), values are Header objects DTO.
     * @type {{ [key: string]: Array<HeaderDTO>; }}
     * @memberof TestResult
     */
    'operationHeaders'?: { [key: string]: Array<HeaderDTO>; };
    /**
     * The maximum time (in milliseconds) to wait for this test ends
     * @type {number}
     * @memberof TestResult
     */
    'timeout'?: number;
    /**
     * 
     * @type {OAuth2AuthorizedClient}
     * @memberof TestResult
     */
    'authorizedClient'?: OAuth2AuthorizedClient;
}


/**
 * Represents the summary result of a Service or API test run by Microcks. 
 * @export
 * @interface TestResultSummary
 */
export interface TestResultSummary {
    /**
     * Unique identifier of TestResult
     * @type {string}
     * @memberof TestResultSummary
     */
    'id': string;
    /**
     * Timestamp of creation date of this service
     * @type {number}
     * @memberof TestResultSummary
     */
    'testDate': number;
    /**
     * Unique identifier of service tested
     * @type {string}
     * @memberof TestResultSummary
     */
    'serviceId': string;
    /**
     * Flag telling if test is a success
     * @type {boolean}
     * @memberof TestResultSummary
     */
    'success': boolean;
}
/**
 * TestReturn is used for wrapping the return code of a test step execution
 * @export
 * @interface TestReturn
 */
export interface TestReturn {
    /**
     * Return code for test (0 means Success, 1 means Failure)
     * @type {number}
     * @memberof TestReturn
     */
    'code': number;
    /**
     * Elapsed time in milliseconds
     * @type {number}
     * @memberof TestReturn
     */
    'elapsedTime': number;
    /**
     * Error message if any
     * @type {string}
     * @memberof TestReturn
     */
    'message'?: string;
    /**
     * 
     * @type {Request}
     * @memberof TestReturn
     */
    'request'?: Request;
    /**
     * 
     * @type {Response}
     * @memberof TestReturn
     */
    'response'?: Response;
    /**
     * 
     * @type {EventMessage}
     * @memberof TestReturn
     */
    'eventMessage'?: EventMessage;
}
/**
 * Type of test strategy (different strategies are implemented by different runners)
 * @export
 * @enum {string}
 */

export const TestRunnerType = {
    Http: 'HTTP',
    SoapHttp: 'SOAP_HTTP',
    SoapUi: 'SOAP_UI',
    Postman: 'POSTMAN',
    OpenApiSchema: 'OPEN_API_SCHEMA',
    AsyncApiSchema: 'ASYNC_API_SCHEMA',
    GrpcProtobuf: 'GRPC_PROTOBUF',
    GraphqlSchema: 'GRAPHQL_SCHEMA'
} as const;

export type TestRunnerType = typeof TestRunnerType[keyof typeof TestRunnerType];


/**
 * TestStepResult is an entity embedded within TestCaseResult. They are created for each request associated with an operation / action of a microservice.
 * @export
 * @interface TestStepResult
 */
export interface TestStepResult {
    /**
     * Flag telling if test case is a success
     * @type {boolean}
     * @memberof TestStepResult
     */
    'success': boolean;
    /**
     * Elapsed time in milliseconds since the test step beginning
     * @type {number}
     * @memberof TestStepResult
     */
    'elapsedTime'?: number;
    /**
     * Name of request this test step is bound to
     * @type {string}
     * @memberof TestStepResult
     */
    'requestName'?: string;
    /**
     * Error message that may be associated to this test step
     * @type {string}
     * @memberof TestStepResult
     */
    'message'?: string;
    /**
     * Name of event this test step is bound to
     * @type {string}
     * @memberof TestStepResult
     */
    'eventMessageName'?: string;
}
/**
 * Evolution trend qualifier
 * @export
 * @enum {string}
 */

export const Trend = {
    Down: 'DOWN',
    LowDown: 'LOW_DOWN',
    Stable: 'STABLE',
    LowUp: 'LOW_UP',
    Up: 'UP'
} as const;

export type Trend = typeof Trend[keyof typeof Trend];


/**
 * Representation of an unidirectional exchange as an event message
 * @export
 * @interface UnidirectionalEvent
 */
export interface UnidirectionalEvent {
    /**
     * Discriminant type for identifying kind of exchange
     * @type {string}
     * @memberof UnidirectionalEvent
     */
    'type': UnidirectionalEventTypeEnum;
    /**
     * 
     * @type {EventMessage}
     * @memberof UnidirectionalEvent
     */
    'eventMessage': EventMessage;
}

export const UnidirectionalEventTypeEnum = {
    ReqRespPair: 'reqRespPair',
    UnidirEvent: 'unidirEvent'
} as const;

export type UnidirectionalEventTypeEnum = typeof UnidirectionalEventTypeEnum[keyof typeof UnidirectionalEventTypeEnum];

/**
 * Value of a metric with an associated weight
 * @export
 * @interface WeightedMetricValue
 */
export interface WeightedMetricValue {
    /**
     * Metric name or serie name
     * @type {string}
     * @memberof WeightedMetricValue
     */
    'name': string;
    /**
     * Weight of this metric value (typically a percentage)
     * @type {number}
     * @memberof WeightedMetricValue
     */
    'weight': number;
    /**
     * The value of this metric
     * @type {number}
     * @memberof WeightedMetricValue
     */
    'value': number;
}

/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Secret
         * @param {Secret} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret: async (secret?: Secret, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/secrets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["admin"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secret, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Secret
         * @summary Delete Secret
         * @param {string} id Unique identifier of Secret to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecret: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSecret', 'id', id)
            const localVarPath = `/secrets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["admin"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get features configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturesConfiguration: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/features/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get authentification configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeycloakConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keycloak/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a Secret
         * @summary Get Secret
         * @param {string} id Unique identifier of Secret to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecret: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSecret', 'id', id)
            const localVarPath = `/secrets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["admin"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Secrets
         * @param {number} [page] Page of Secrets to retrieve (starts at and defaults to 0)
         * @param {number} [size] Size of a page. Maximum number of Secrets to include in a response (defaults to 20)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecrets: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/secrets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Secrets counter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecretsCounter: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/secrets/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Secret
         * @summary Update Secret
         * @param {string} id Unique identifier of Secret to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSecret: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSecret', 'id', id)
            const localVarPath = `/secrets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["admin"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Secret
         * @param {Secret} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSecret(secret?: Secret, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSecret(secret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.createSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Secret
         * @summary Delete Secret
         * @param {string} id Unique identifier of Secret to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSecret(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSecret(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.deleteSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get features configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeaturesConfiguration(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeaturesConfiguration(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.getFeaturesConfiguration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get authentification configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeycloakConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeycloakConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeycloakConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.getKeycloakConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a Secret
         * @summary Get Secret
         * @param {string} id Unique identifier of Secret to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecret(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecret(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.getSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Secrets
         * @param {number} [page] Page of Secrets to retrieve (starts at and defaults to 0)
         * @param {number} [size] Size of a page. Maximum number of Secrets to include in a response (defaults to 20)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecrets(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Secret>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecrets(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.getSecrets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Secrets counter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecretsCounter(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Counter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecretsCounter(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.getSecretsCounter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Secret
         * @summary Update Secret
         * @param {string} id Unique identifier of Secret to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSecret(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSecret(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.updateSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Secret
         * @param {ConfigApiCreateSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret(requestParameters: ConfigApiCreateSecretRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createSecret(requestParameters.secret, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Secret
         * @summary Delete Secret
         * @param {ConfigApiDeleteSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecret(requestParameters: ConfigApiDeleteSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSecret(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get features configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturesConfiguration(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getFeaturesConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get authentification configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeycloakConfig(options?: RawAxiosRequestConfig): AxiosPromise<KeycloakConfig> {
            return localVarFp.getKeycloakConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a Secret
         * @summary Get Secret
         * @param {ConfigApiGetSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecret(requestParameters: ConfigApiGetSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.getSecret(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Secrets
         * @param {ConfigApiGetSecretsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecrets(requestParameters: ConfigApiGetSecretsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<Secret>> {
            return localVarFp.getSecrets(requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Secrets counter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecretsCounter(options?: RawAxiosRequestConfig): AxiosPromise<Counter> {
            return localVarFp.getSecretsCounter(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Secret
         * @summary Update Secret
         * @param {ConfigApiUpdateSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSecret(requestParameters: ConfigApiUpdateSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateSecret(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSecret operation in ConfigApi.
 * @export
 * @interface ConfigApiCreateSecretRequest
 */
export interface ConfigApiCreateSecretRequest {
    /**
     * 
     * @type {Secret}
     * @memberof ConfigApiCreateSecret
     */
    readonly secret?: Secret
}

/**
 * Request parameters for deleteSecret operation in ConfigApi.
 * @export
 * @interface ConfigApiDeleteSecretRequest
 */
export interface ConfigApiDeleteSecretRequest {
    /**
     * Unique identifier of Secret to manage
     * @type {string}
     * @memberof ConfigApiDeleteSecret
     */
    readonly id: string
}

/**
 * Request parameters for getSecret operation in ConfigApi.
 * @export
 * @interface ConfigApiGetSecretRequest
 */
export interface ConfigApiGetSecretRequest {
    /**
     * Unique identifier of Secret to manage
     * @type {string}
     * @memberof ConfigApiGetSecret
     */
    readonly id: string
}

/**
 * Request parameters for getSecrets operation in ConfigApi.
 * @export
 * @interface ConfigApiGetSecretsRequest
 */
export interface ConfigApiGetSecretsRequest {
    /**
     * Page of Secrets to retrieve (starts at and defaults to 0)
     * @type {number}
     * @memberof ConfigApiGetSecrets
     */
    readonly page?: number

    /**
     * Size of a page. Maximum number of Secrets to include in a response (defaults to 20)
     * @type {number}
     * @memberof ConfigApiGetSecrets
     */
    readonly size?: number
}

/**
 * Request parameters for updateSecret operation in ConfigApi.
 * @export
 * @interface ConfigApiUpdateSecretRequest
 */
export interface ConfigApiUpdateSecretRequest {
    /**
     * Unique identifier of Secret to manage
     * @type {string}
     * @memberof ConfigApiUpdateSecret
     */
    readonly id: string
}

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Secret
     * @param {ConfigApiCreateSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public createSecret(requestParameters: ConfigApiCreateSecretRequest = {}, options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).createSecret(requestParameters.secret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Secret
     * @summary Delete Secret
     * @param {ConfigApiDeleteSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public deleteSecret(requestParameters: ConfigApiDeleteSecretRequest, options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).deleteSecret(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get features configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public getFeaturesConfiguration(options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).getFeaturesConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get authentification configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public getKeycloakConfig(options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).getKeycloakConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a Secret
     * @summary Get Secret
     * @param {ConfigApiGetSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public getSecret(requestParameters: ConfigApiGetSecretRequest, options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).getSecret(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Secrets
     * @param {ConfigApiGetSecretsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public getSecrets(requestParameters: ConfigApiGetSecretsRequest = {}, options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).getSecrets(requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Secrets counter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public getSecretsCounter(options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).getSecretsCounter(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Secret
     * @summary Update Secret
     * @param {ConfigApiUpdateSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public updateSecret(requestParameters: ConfigApiUpdateSecretRequest, options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).updateSecret(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Resource
         * @param {string} name Unique name/business identifier of the Service or API resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResource: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getResource', 'name', name)
            const localVarPath = `/resources/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Resources by Service
         * @param {string} serviceId Unique identifier of the Service or API the resources are attached to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcesByService: async (serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getResourcesByService', 'serviceId', serviceId)
            const localVarPath = `/resources/service/{serviceId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Resource
         * @param {string} name Unique name/business identifier of the Service or API resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResource(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResource(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Resources by Service
         * @param {string} serviceId Unique identifier of the Service or API the resources are attached to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourcesByService(serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Resource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourcesByService(serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getResourcesByService']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Resource
         * @param {DefaultApiGetResourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResource(requestParameters: DefaultApiGetResourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Resource> {
            return localVarFp.getResource(requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Resources by Service
         * @param {DefaultApiGetResourcesByServiceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcesByService(requestParameters: DefaultApiGetResourcesByServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Resource>> {
            return localVarFp.getResourcesByService(requestParameters.serviceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getResource operation in DefaultApi.
 * @export
 * @interface DefaultApiGetResourceRequest
 */
export interface DefaultApiGetResourceRequest {
    /**
     * Unique name/business identifier of the Service or API resource
     * @type {string}
     * @memberof DefaultApiGetResource
     */
    readonly name: string
}

/**
 * Request parameters for getResourcesByService operation in DefaultApi.
 * @export
 * @interface DefaultApiGetResourcesByServiceRequest
 */
export interface DefaultApiGetResourcesByServiceRequest {
    /**
     * Unique identifier of the Service or API the resources are attached to
     * @type {string}
     * @memberof DefaultApiGetResourcesByService
     */
    readonly serviceId: string
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get Resource
     * @param {DefaultApiGetResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getResource(requestParameters: DefaultApiGetResourceRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getResource(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Resources by Service
     * @param {DefaultApiGetResourcesByServiceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getResourcesByService(requestParameters: DefaultApiGetResourcesByServiceRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getResourcesByService(requestParameters.serviceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Make an ImportJob active, so that it is executed
         * @summary Activate an ImportJob
         * @param {string} id Unique identifier of ImportJob to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateImportJob: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('activateImportJob', 'id', id)
            const localVarPath = `/jobs/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["manager", "admin"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ImportJob
         * @summary Create ImportJob
         * @param {ImportJob} importJob 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportJob: async (importJob: ImportJob, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importJob' is not null or undefined
            assertParamExists('createImportJob', 'importJob', importJob)
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importJob, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an ImportJob
         * @summary Delete ImportJob
         * @param {string} id Unique identifier of ImportJob to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImportJob: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteImportJob', 'id', id)
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["admin"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the ImportJobs counter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportJobCounter: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of ImportJobs
         * @summary Get ImportJobs
         * @param {number} [page] Page of ImportJobs to retrieve (starts at and defaults to 0)
         * @param {number} [size] Size of a page. Maximum number of ImportJobs to include in a response (defaults to 20)
         * @param {string} [name] Name like criterion for query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportJobs: async (page?: number, size?: number, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an ImportJob using its identifier
         * @summary Get ImportJob
         * @param {string} id Unique identifier of ImportJob to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsIdGet', 'id', id)
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an ImportJob
         * @summary Update ImportJob
         * @param {string} id Unique identifier of ImportJob to manage
         * @param {ImportJob} importJob 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsIdPost: async (id: string, importJob: ImportJob, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsIdPost', 'id', id)
            // verify required parameter 'importJob' is not null or undefined
            assertParamExists('jobsIdPost', 'importJob', importJob)
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importJob, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starting an ImportJob forces it to immediatly import mock definitions
         * @summary Start an ImportJob
         * @param {string} id Unique identifier of ImportJob to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startImportJob: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startImportJob', 'id', id)
            const localVarPath = `/jobs/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["manager", "admin"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stopping an ImportJob desactivate it, so that it won\'t execute at next schedule
         * @summary Stop an ImportJob
         * @param {string} id Unique identifier of ImportJob to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopImportJob: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stopImportJob', 'id', id)
            const localVarPath = `/jobs/{id}/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["manager", "admin"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads an artifact to be imported by Microcks.
         * @summary Upload an artifact
         * @param {boolean} mainArtifact Flag telling if this should be considered as primary or secondary artifact. Default to \&#39;true\&#39;
         * @param {File} file The artifact to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact: async (mainArtifact: boolean, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mainArtifact' is not null or undefined
            assertParamExists('uploadArtifact', 'mainArtifact', mainArtifact)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadArtifact', 'file', file)
            const localVarPath = `/artifact/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)

            if (mainArtifact !== undefined) {
                localVarQueryParameter['mainArtifact'] = mainArtifact;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobApiAxiosParamCreator(configuration)
    return {
        /**
         * Make an ImportJob active, so that it is executed
         * @summary Activate an ImportJob
         * @param {string} id Unique identifier of ImportJob to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateImportJob(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateImportJob(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.activateImportJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new ImportJob
         * @summary Create ImportJob
         * @param {ImportJob} importJob 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImportJob(importJob: ImportJob, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImportJob(importJob, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.createImportJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an ImportJob
         * @summary Delete ImportJob
         * @param {string} id Unique identifier of ImportJob to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImportJob(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImportJob(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.deleteImportJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the ImportJobs counter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportJobCounter(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Counter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportJobCounter(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.getImportJobCounter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of ImportJobs
         * @summary Get ImportJobs
         * @param {number} [page] Page of ImportJobs to retrieve (starts at and defaults to 0)
         * @param {number} [size] Size of a page. Maximum number of ImportJobs to include in a response (defaults to 20)
         * @param {string} [name] Name like criterion for query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportJobs(page?: number, size?: number, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImportJob>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportJobs(page, size, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.getImportJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an ImportJob using its identifier
         * @summary Get ImportJob
         * @param {string} id Unique identifier of ImportJob to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.jobsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an ImportJob
         * @summary Update ImportJob
         * @param {string} id Unique identifier of ImportJob to manage
         * @param {ImportJob} importJob 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsIdPost(id: string, importJob: ImportJob, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsIdPost(id, importJob, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.jobsIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starting an ImportJob forces it to immediatly import mock definitions
         * @summary Start an ImportJob
         * @param {string} id Unique identifier of ImportJob to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startImportJob(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startImportJob(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.startImportJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stopping an ImportJob desactivate it, so that it won\'t execute at next schedule
         * @summary Stop an ImportJob
         * @param {string} id Unique identifier of ImportJob to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopImportJob(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopImportJob(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.stopImportJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads an artifact to be imported by Microcks.
         * @summary Upload an artifact
         * @param {boolean} mainArtifact Flag telling if this should be considered as primary or secondary artifact. Default to \&#39;true\&#39;
         * @param {File} file The artifact to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadArtifact(mainArtifact: boolean, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadArtifact(mainArtifact, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.uploadArtifact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobApiFp(configuration)
    return {
        /**
         * Make an ImportJob active, so that it is executed
         * @summary Activate an ImportJob
         * @param {JobApiActivateImportJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateImportJob(requestParameters: JobApiActivateImportJobRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImportJob> {
            return localVarFp.activateImportJob(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new ImportJob
         * @summary Create ImportJob
         * @param {JobApiCreateImportJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportJob(requestParameters: JobApiCreateImportJobRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImportJob> {
            return localVarFp.createImportJob(requestParameters.importJob, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an ImportJob
         * @summary Delete ImportJob
         * @param {JobApiDeleteImportJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImportJob(requestParameters: JobApiDeleteImportJobRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteImportJob(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the ImportJobs counter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportJobCounter(options?: RawAxiosRequestConfig): AxiosPromise<Counter> {
            return localVarFp.getImportJobCounter(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of ImportJobs
         * @summary Get ImportJobs
         * @param {JobApiGetImportJobsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportJobs(requestParameters: JobApiGetImportJobsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<ImportJob>> {
            return localVarFp.getImportJobs(requestParameters.page, requestParameters.size, requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an ImportJob using its identifier
         * @summary Get ImportJob
         * @param {JobApiJobsIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsIdGet(requestParameters: JobApiJobsIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImportJob> {
            return localVarFp.jobsIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an ImportJob
         * @summary Update ImportJob
         * @param {JobApiJobsIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsIdPost(requestParameters: JobApiJobsIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImportJob> {
            return localVarFp.jobsIdPost(requestParameters.id, requestParameters.importJob, options).then((request) => request(axios, basePath));
        },
        /**
         * Starting an ImportJob forces it to immediatly import mock definitions
         * @summary Start an ImportJob
         * @param {JobApiStartImportJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startImportJob(requestParameters: JobApiStartImportJobRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImportJob> {
            return localVarFp.startImportJob(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Stopping an ImportJob desactivate it, so that it won\'t execute at next schedule
         * @summary Stop an ImportJob
         * @param {JobApiStopImportJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopImportJob(requestParameters: JobApiStopImportJobRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImportJob> {
            return localVarFp.stopImportJob(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads an artifact to be imported by Microcks.
         * @summary Upload an artifact
         * @param {JobApiUploadArtifactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(requestParameters: JobApiUploadArtifactRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.uploadArtifact(requestParameters.mainArtifact, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for activateImportJob operation in JobApi.
 * @export
 * @interface JobApiActivateImportJobRequest
 */
export interface JobApiActivateImportJobRequest {
    /**
     * Unique identifier of ImportJob to manage
     * @type {string}
     * @memberof JobApiActivateImportJob
     */
    readonly id: string
}

/**
 * Request parameters for createImportJob operation in JobApi.
 * @export
 * @interface JobApiCreateImportJobRequest
 */
export interface JobApiCreateImportJobRequest {
    /**
     * 
     * @type {ImportJob}
     * @memberof JobApiCreateImportJob
     */
    readonly importJob: ImportJob
}

/**
 * Request parameters for deleteImportJob operation in JobApi.
 * @export
 * @interface JobApiDeleteImportJobRequest
 */
export interface JobApiDeleteImportJobRequest {
    /**
     * Unique identifier of ImportJob to manage
     * @type {string}
     * @memberof JobApiDeleteImportJob
     */
    readonly id: string
}

/**
 * Request parameters for getImportJobs operation in JobApi.
 * @export
 * @interface JobApiGetImportJobsRequest
 */
export interface JobApiGetImportJobsRequest {
    /**
     * Page of ImportJobs to retrieve (starts at and defaults to 0)
     * @type {number}
     * @memberof JobApiGetImportJobs
     */
    readonly page?: number

    /**
     * Size of a page. Maximum number of ImportJobs to include in a response (defaults to 20)
     * @type {number}
     * @memberof JobApiGetImportJobs
     */
    readonly size?: number

    /**
     * Name like criterion for query
     * @type {string}
     * @memberof JobApiGetImportJobs
     */
    readonly name?: string
}

/**
 * Request parameters for jobsIdGet operation in JobApi.
 * @export
 * @interface JobApiJobsIdGetRequest
 */
export interface JobApiJobsIdGetRequest {
    /**
     * Unique identifier of ImportJob to manage
     * @type {string}
     * @memberof JobApiJobsIdGet
     */
    readonly id: string
}

/**
 * Request parameters for jobsIdPost operation in JobApi.
 * @export
 * @interface JobApiJobsIdPostRequest
 */
export interface JobApiJobsIdPostRequest {
    /**
     * Unique identifier of ImportJob to manage
     * @type {string}
     * @memberof JobApiJobsIdPost
     */
    readonly id: string

    /**
     * 
     * @type {ImportJob}
     * @memberof JobApiJobsIdPost
     */
    readonly importJob: ImportJob
}

/**
 * Request parameters for startImportJob operation in JobApi.
 * @export
 * @interface JobApiStartImportJobRequest
 */
export interface JobApiStartImportJobRequest {
    /**
     * Unique identifier of ImportJob to manage
     * @type {string}
     * @memberof JobApiStartImportJob
     */
    readonly id: string
}

/**
 * Request parameters for stopImportJob operation in JobApi.
 * @export
 * @interface JobApiStopImportJobRequest
 */
export interface JobApiStopImportJobRequest {
    /**
     * Unique identifier of ImportJob to manage
     * @type {string}
     * @memberof JobApiStopImportJob
     */
    readonly id: string
}

/**
 * Request parameters for uploadArtifact operation in JobApi.
 * @export
 * @interface JobApiUploadArtifactRequest
 */
export interface JobApiUploadArtifactRequest {
    /**
     * Flag telling if this should be considered as primary or secondary artifact. Default to \&#39;true\&#39;
     * @type {boolean}
     * @memberof JobApiUploadArtifact
     */
    readonly mainArtifact: boolean

    /**
     * The artifact to upload
     * @type {File}
     * @memberof JobApiUploadArtifact
     */
    readonly file: File
}

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * Make an ImportJob active, so that it is executed
     * @summary Activate an ImportJob
     * @param {JobApiActivateImportJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public activateImportJob(requestParameters: JobApiActivateImportJobRequest, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).activateImportJob(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new ImportJob
     * @summary Create ImportJob
     * @param {JobApiCreateImportJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public createImportJob(requestParameters: JobApiCreateImportJobRequest, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).createImportJob(requestParameters.importJob, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an ImportJob
     * @summary Delete ImportJob
     * @param {JobApiDeleteImportJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public deleteImportJob(requestParameters: JobApiDeleteImportJobRequest, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).deleteImportJob(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the ImportJobs counter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getImportJobCounter(options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).getImportJobCounter(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of ImportJobs
     * @summary Get ImportJobs
     * @param {JobApiGetImportJobsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getImportJobs(requestParameters: JobApiGetImportJobsRequest = {}, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).getImportJobs(requestParameters.page, requestParameters.size, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an ImportJob using its identifier
     * @summary Get ImportJob
     * @param {JobApiJobsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public jobsIdGet(requestParameters: JobApiJobsIdGetRequest, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).jobsIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an ImportJob
     * @summary Update ImportJob
     * @param {JobApiJobsIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public jobsIdPost(requestParameters: JobApiJobsIdPostRequest, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).jobsIdPost(requestParameters.id, requestParameters.importJob, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starting an ImportJob forces it to immediatly import mock definitions
     * @summary Start an ImportJob
     * @param {JobApiStartImportJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public startImportJob(requestParameters: JobApiStartImportJobRequest, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).startImportJob(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stopping an ImportJob desactivate it, so that it won\'t execute at next schedule
     * @summary Stop an ImportJob
     * @param {JobApiStopImportJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public stopImportJob(requestParameters: JobApiStopImportJobRequest, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).stopImportJob(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads an artifact to be imported by Microcks.
     * @summary Upload an artifact
     * @param {JobApiUploadArtifactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public uploadArtifact(requestParameters: JobApiUploadArtifactRequest, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).uploadArtifact(requestParameters.mainArtifact, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get aggregated invocation statistics for a day
         * @param {string} [day] The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedInvocationsStats: async (day?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics/invocations/global`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", [], configuration)

            if (day !== undefined) {
                localVarQueryParameter['day'] = day;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get aggregation of conformance metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConformanceMetricsAggregation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics/conformance/aggregate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invocation statistics for Service
         * @param {string} serviceName Name of service to get statistics for
         * @param {string} serviceVersion Version of service to get statistics for
         * @param {string} [day] The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvocationStatsByService: async (serviceName: string, serviceVersion: string, day?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceName' is not null or undefined
            assertParamExists('getInvocationStatsByService', 'serviceName', serviceName)
            // verify required parameter 'serviceVersion' is not null or undefined
            assertParamExists('getInvocationStatsByService', 'serviceVersion', serviceVersion)
            const localVarPath = `/metrics/invocations/{serviceName}/{serviceVersion}`
                .replace(`{${"serviceName"}}`, encodeURIComponent(String(serviceName)))
                .replace(`{${"serviceVersion"}}`, encodeURIComponent(String(serviceVersion)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", [], configuration)

            if (day !== undefined) {
                localVarQueryParameter['day'] = day;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get aggregated invocations statistics for latest days
         * @param {number} [limit] Number of days to get back in time. Default is 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestAggregatedInvocationsStats: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics/invocations/global/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get latest tests results
         * @param {number} [limit] Number of days to consider for test results to return. Default is 7 (one week)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestTestResults: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics/tests/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get conformance metrics for a Service
         * @param {string} serviceId Unique Services identifier this metrics are related to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceTestConformanceMetric: async (serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getServiceTestConformanceMetric', 'serviceId', serviceId)
            const localVarPath = `/metrics/conformance/service/{serviceId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get top invocation statistics for a day
         * @param {string} [day] The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.
         * @param {number} [limit] The number of top invoked mocks to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopIvnocationsStatsByDay: async (day?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics/invocations/top`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", [], configuration)

            if (day !== undefined) {
                localVarQueryParameter['day'] = day;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get aggregated invocation statistics for a day
         * @param {string} [day] The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggregatedInvocationsStats(day?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DailyInvocationStatistic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggregatedInvocationsStats(day, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.getAggregatedInvocationsStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get aggregation of conformance metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConformanceMetricsAggregation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WeightedMetricValue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConformanceMetricsAggregation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.getConformanceMetricsAggregation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get invocation statistics for Service
         * @param {string} serviceName Name of service to get statistics for
         * @param {string} serviceVersion Version of service to get statistics for
         * @param {string} [day] The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvocationStatsByService(serviceName: string, serviceVersion: string, day?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DailyInvocationStatistic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvocationStatsByService(serviceName, serviceVersion, day, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.getInvocationStatsByService']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get aggregated invocations statistics for latest days
         * @param {number} [limit] Number of days to get back in time. Default is 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestAggregatedInvocationsStats(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestAggregatedInvocationsStats(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.getLatestAggregatedInvocationsStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get latest tests results
         * @param {number} [limit] Number of days to consider for test results to return. Default is 7 (one week)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestTestResults(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestResultSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestTestResults(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.getLatestTestResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get conformance metrics for a Service
         * @param {string} serviceId Unique Services identifier this metrics are related to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceTestConformanceMetric(serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestConformanceMetric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceTestConformanceMetric(serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.getServiceTestConformanceMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get top invocation statistics for a day
         * @param {string} [day] The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.
         * @param {number} [limit] The number of top invoked mocks to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopIvnocationsStatsByDay(day?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DailyInvocationStatistic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopIvnocationsStatsByDay(day, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.getTopIvnocationsStatsByDay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get aggregated invocation statistics for a day
         * @param {MetricsApiGetAggregatedInvocationsStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedInvocationsStats(requestParameters: MetricsApiGetAggregatedInvocationsStatsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<DailyInvocationStatistic> {
            return localVarFp.getAggregatedInvocationsStats(requestParameters.day, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get aggregation of conformance metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConformanceMetricsAggregation(options?: RawAxiosRequestConfig): AxiosPromise<Array<WeightedMetricValue>> {
            return localVarFp.getConformanceMetricsAggregation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get invocation statistics for Service
         * @param {MetricsApiGetInvocationStatsByServiceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvocationStatsByService(requestParameters: MetricsApiGetInvocationStatsByServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<DailyInvocationStatistic> {
            return localVarFp.getInvocationStatsByService(requestParameters.serviceName, requestParameters.serviceVersion, requestParameters.day, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get aggregated invocations statistics for latest days
         * @param {MetricsApiGetLatestAggregatedInvocationsStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestAggregatedInvocationsStats(requestParameters: MetricsApiGetLatestAggregatedInvocationsStatsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getLatestAggregatedInvocationsStats(requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get latest tests results
         * @param {MetricsApiGetLatestTestResultsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestTestResults(requestParameters: MetricsApiGetLatestTestResultsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<TestResultSummary>> {
            return localVarFp.getLatestTestResults(requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get conformance metrics for a Service
         * @param {MetricsApiGetServiceTestConformanceMetricRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceTestConformanceMetric(requestParameters: MetricsApiGetServiceTestConformanceMetricRequest, options?: RawAxiosRequestConfig): AxiosPromise<TestConformanceMetric> {
            return localVarFp.getServiceTestConformanceMetric(requestParameters.serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get top invocation statistics for a day
         * @param {MetricsApiGetTopIvnocationsStatsByDayRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopIvnocationsStatsByDay(requestParameters: MetricsApiGetTopIvnocationsStatsByDayRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<DailyInvocationStatistic>> {
            return localVarFp.getTopIvnocationsStatsByDay(requestParameters.day, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAggregatedInvocationsStats operation in MetricsApi.
 * @export
 * @interface MetricsApiGetAggregatedInvocationsStatsRequest
 */
export interface MetricsApiGetAggregatedInvocationsStatsRequest {
    /**
     * The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.
     * @type {string}
     * @memberof MetricsApiGetAggregatedInvocationsStats
     */
    readonly day?: string
}

/**
 * Request parameters for getInvocationStatsByService operation in MetricsApi.
 * @export
 * @interface MetricsApiGetInvocationStatsByServiceRequest
 */
export interface MetricsApiGetInvocationStatsByServiceRequest {
    /**
     * Name of service to get statistics for
     * @type {string}
     * @memberof MetricsApiGetInvocationStatsByService
     */
    readonly serviceName: string

    /**
     * Version of service to get statistics for
     * @type {string}
     * @memberof MetricsApiGetInvocationStatsByService
     */
    readonly serviceVersion: string

    /**
     * The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.
     * @type {string}
     * @memberof MetricsApiGetInvocationStatsByService
     */
    readonly day?: string
}

/**
 * Request parameters for getLatestAggregatedInvocationsStats operation in MetricsApi.
 * @export
 * @interface MetricsApiGetLatestAggregatedInvocationsStatsRequest
 */
export interface MetricsApiGetLatestAggregatedInvocationsStatsRequest {
    /**
     * Number of days to get back in time. Default is 20.
     * @type {number}
     * @memberof MetricsApiGetLatestAggregatedInvocationsStats
     */
    readonly limit?: number
}

/**
 * Request parameters for getLatestTestResults operation in MetricsApi.
 * @export
 * @interface MetricsApiGetLatestTestResultsRequest
 */
export interface MetricsApiGetLatestTestResultsRequest {
    /**
     * Number of days to consider for test results to return. Default is 7 (one week)
     * @type {number}
     * @memberof MetricsApiGetLatestTestResults
     */
    readonly limit?: number
}

/**
 * Request parameters for getServiceTestConformanceMetric operation in MetricsApi.
 * @export
 * @interface MetricsApiGetServiceTestConformanceMetricRequest
 */
export interface MetricsApiGetServiceTestConformanceMetricRequest {
    /**
     * Unique Services identifier this metrics are related to
     * @type {string}
     * @memberof MetricsApiGetServiceTestConformanceMetric
     */
    readonly serviceId: string
}

/**
 * Request parameters for getTopIvnocationsStatsByDay operation in MetricsApi.
 * @export
 * @interface MetricsApiGetTopIvnocationsStatsByDayRequest
 */
export interface MetricsApiGetTopIvnocationsStatsByDayRequest {
    /**
     * The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.
     * @type {string}
     * @memberof MetricsApiGetTopIvnocationsStatsByDay
     */
    readonly day?: string

    /**
     * The number of top invoked mocks to return
     * @type {number}
     * @memberof MetricsApiGetTopIvnocationsStatsByDay
     */
    readonly limit?: number
}

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @summary Get aggregated invocation statistics for a day
     * @param {MetricsApiGetAggregatedInvocationsStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getAggregatedInvocationsStats(requestParameters: MetricsApiGetAggregatedInvocationsStatsRequest = {}, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getAggregatedInvocationsStats(requestParameters.day, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get aggregation of conformance metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getConformanceMetricsAggregation(options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getConformanceMetricsAggregation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get invocation statistics for Service
     * @param {MetricsApiGetInvocationStatsByServiceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getInvocationStatsByService(requestParameters: MetricsApiGetInvocationStatsByServiceRequest, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getInvocationStatsByService(requestParameters.serviceName, requestParameters.serviceVersion, requestParameters.day, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get aggregated invocations statistics for latest days
     * @param {MetricsApiGetLatestAggregatedInvocationsStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getLatestAggregatedInvocationsStats(requestParameters: MetricsApiGetLatestAggregatedInvocationsStatsRequest = {}, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getLatestAggregatedInvocationsStats(requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get latest tests results
     * @param {MetricsApiGetLatestTestResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getLatestTestResults(requestParameters: MetricsApiGetLatestTestResultsRequest = {}, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getLatestTestResults(requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get conformance metrics for a Service
     * @param {MetricsApiGetServiceTestConformanceMetricRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getServiceTestConformanceMetric(requestParameters: MetricsApiGetServiceTestConformanceMetricRequest, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getServiceTestConformanceMetric(requestParameters.serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get top invocation statistics for a day
     * @param {MetricsApiGetTopIvnocationsStatsByDayRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getTopIvnocationsStatsByDay(requestParameters: MetricsApiGetTopIvnocationsStatsByDayRequest = {}, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getTopIvnocationsStatsByDay(requestParameters.day, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MockApi - axios parameter creator
 * @export
 */
export const MockApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a Service
         * @summary Delete Service
         * @param {string} id Unique identifier of Service to managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteService: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteService', 'id', id)
            const localVarPath = `/services/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["admin", "manager"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export a repostiory snapshot with requested services
         * @summary Export a snapshot
         * @param {Array<string>} serviceIds List of service identifiers to export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportSnapshot: async (serviceIds: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceIds' is not null or undefined
            assertParamExists('exportSnapshot', 'serviceIds', serviceIds)
            const localVarPath = `/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["admin"], configuration)

            if (serviceIds) {
                localVarQueryParameter['serviceIds'] = serviceIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Service
         * @param {string} id Unique identifier of Service to managed
         * @param {boolean} [messages] Whether to include details on services messages into result. Default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getService: async (id: string, messages?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getService', 'id', id)
            const localVarPath = `/services/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)

            if (messages !== undefined) {
                localVarQueryParameter['messages'] = messages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Services and APIs
         * @param {number} [page] Page of Services to retrieve (starts at and defaults to 0)
         * @param {number} [size] Size of a page. Maximum number of Services to include in a response (defaults to 20)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Services counter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServicesCounter: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the already used labels for Services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServicesLabels: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services/labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import a repository snapshot previsouly exported into Microcks
         * @summary Import a snapshot
         * @param {File} file The repository snapshot file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSnapshot: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importSnapshot', 'file', file)
            const localVarPath = `/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["admin"], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Override Service Operation
         * @param {string} id Unique identifier of Service to managed
         * @param {string} operationName Name of operation to update
         * @param {OperationOverrideDTO} operationOverrideDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overrideServiceOperation: async (id: string, operationName: string, operationOverrideDTO: OperationOverrideDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('overrideServiceOperation', 'id', id)
            // verify required parameter 'operationName' is not null or undefined
            assertParamExists('overrideServiceOperation', 'operationName', operationName)
            // verify required parameter 'operationOverrideDTO' is not null or undefined
            assertParamExists('overrideServiceOperation', 'operationOverrideDTO', operationOverrideDTO)
            const localVarPath = `/services/{id}/operation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["admin", "manager"], configuration)

            if (operationName !== undefined) {
                localVarQueryParameter['operationName'] = operationName;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operationOverrideDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for Services and APIs
         * @param {{ [key: string]: string; }} queryMap Map of criterion. Key can be simply \&#39;name\&#39; with value as the searched string. You can also search by label using keys like \&#39;labels.x\&#39; where \&#39;x\&#39; is the label and value the label value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchServices: async (queryMap: { [key: string]: string; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryMap' is not null or undefined
            assertParamExists('searchServices', 'queryMap', queryMap)
            const localVarPath = `/services/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)

            if (queryMap !== undefined) {
                for (const [key, value] of Object.entries(queryMap)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Service Metadata
         * @param {string} id Unique identifier of Service to managed
         * @param {Metadata} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceMetadata: async (id: string, metadata: Metadata, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateServiceMetadata', 'id', id)
            // verify required parameter 'metadata' is not null or undefined
            assertParamExists('updateServiceMetadata', 'metadata', metadata)
            const localVarPath = `/services/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["admin", "manager"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MockApi - functional programming interface
 * @export
 */
export const MockApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MockApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a Service
         * @summary Delete Service
         * @param {string} id Unique identifier of Service to managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteService(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteService(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockApi.deleteService']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export a repostiory snapshot with requested services
         * @summary Export a snapshot
         * @param {Array<string>} serviceIds List of service identifiers to export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportSnapshot(serviceIds: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportSnapshot(serviceIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockApi.exportSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Service
         * @param {string} id Unique identifier of Service to managed
         * @param {boolean} [messages] Whether to include details on services messages into result. Default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getService(id: string, messages?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetService200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getService(id, messages, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockApi.getService']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Services and APIs
         * @param {number} [page] Page of Services to retrieve (starts at and defaults to 0)
         * @param {number} [size] Size of a page. Maximum number of Services to include in a response (defaults to 20)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServices(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServices(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockApi.getServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Services counter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServicesCounter(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Counter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServicesCounter(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockApi.getServicesCounter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the already used labels for Services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServicesLabels(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<string>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServicesLabels(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockApi.getServicesLabels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import a repository snapshot previsouly exported into Microcks
         * @summary Import a snapshot
         * @param {File} file The repository snapshot file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importSnapshot(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importSnapshot(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockApi.importSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Override Service Operation
         * @param {string} id Unique identifier of Service to managed
         * @param {string} operationName Name of operation to update
         * @param {OperationOverrideDTO} operationOverrideDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async overrideServiceOperation(id: string, operationName: string, operationOverrideDTO: OperationOverrideDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.overrideServiceOperation(id, operationName, operationOverrideDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockApi.overrideServiceOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for Services and APIs
         * @param {{ [key: string]: string; }} queryMap Map of criterion. Key can be simply \&#39;name\&#39; with value as the searched string. You can also search by label using keys like \&#39;labels.x\&#39; where \&#39;x\&#39; is the label and value the label value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchServices(queryMap: { [key: string]: string; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Service>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchServices(queryMap, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockApi.searchServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Service Metadata
         * @param {string} id Unique identifier of Service to managed
         * @param {Metadata} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateServiceMetadata(id: string, metadata: Metadata, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateServiceMetadata(id, metadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MockApi.updateServiceMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MockApi - factory interface
 * @export
 */
export const MockApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MockApiFp(configuration)
    return {
        /**
         * Delete a Service
         * @summary Delete Service
         * @param {MockApiDeleteServiceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteService(requestParameters: MockApiDeleteServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteService(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Export a repostiory snapshot with requested services
         * @summary Export a snapshot
         * @param {MockApiExportSnapshotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportSnapshot(requestParameters: MockApiExportSnapshotRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.exportSnapshot(requestParameters.serviceIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Service
         * @param {MockApiGetServiceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getService(requestParameters: MockApiGetServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetService200Response> {
            return localVarFp.getService(requestParameters.id, requestParameters.messages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Services and APIs
         * @param {MockApiGetServicesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices(requestParameters: MockApiGetServicesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Service> {
            return localVarFp.getServices(requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Services counter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServicesCounter(options?: RawAxiosRequestConfig): AxiosPromise<Counter> {
            return localVarFp.getServicesCounter(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the already used labels for Services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServicesLabels(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<string>; }> {
            return localVarFp.getServicesLabels(options).then((request) => request(axios, basePath));
        },
        /**
         * Import a repository snapshot previsouly exported into Microcks
         * @summary Import a snapshot
         * @param {MockApiImportSnapshotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSnapshot(requestParameters: MockApiImportSnapshotRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.importSnapshot(requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Override Service Operation
         * @param {MockApiOverrideServiceOperationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overrideServiceOperation(requestParameters: MockApiOverrideServiceOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.overrideServiceOperation(requestParameters.id, requestParameters.operationName, requestParameters.operationOverrideDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for Services and APIs
         * @param {MockApiSearchServicesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchServices(requestParameters: MockApiSearchServicesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Service>> {
            return localVarFp.searchServices(requestParameters.queryMap, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Service Metadata
         * @param {MockApiUpdateServiceMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceMetadata(requestParameters: MockApiUpdateServiceMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateServiceMetadata(requestParameters.id, requestParameters.metadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteService operation in MockApi.
 * @export
 * @interface MockApiDeleteServiceRequest
 */
export interface MockApiDeleteServiceRequest {
    /**
     * Unique identifier of Service to managed
     * @type {string}
     * @memberof MockApiDeleteService
     */
    readonly id: string
}

/**
 * Request parameters for exportSnapshot operation in MockApi.
 * @export
 * @interface MockApiExportSnapshotRequest
 */
export interface MockApiExportSnapshotRequest {
    /**
     * List of service identifiers to export
     * @type {Array<string>}
     * @memberof MockApiExportSnapshot
     */
    readonly serviceIds: Array<string>
}

/**
 * Request parameters for getService operation in MockApi.
 * @export
 * @interface MockApiGetServiceRequest
 */
export interface MockApiGetServiceRequest {
    /**
     * Unique identifier of Service to managed
     * @type {string}
     * @memberof MockApiGetService
     */
    readonly id: string

    /**
     * Whether to include details on services messages into result. Default is false
     * @type {boolean}
     * @memberof MockApiGetService
     */
    readonly messages?: boolean
}

/**
 * Request parameters for getServices operation in MockApi.
 * @export
 * @interface MockApiGetServicesRequest
 */
export interface MockApiGetServicesRequest {
    /**
     * Page of Services to retrieve (starts at and defaults to 0)
     * @type {number}
     * @memberof MockApiGetServices
     */
    readonly page?: number

    /**
     * Size of a page. Maximum number of Services to include in a response (defaults to 20)
     * @type {number}
     * @memberof MockApiGetServices
     */
    readonly size?: number
}

/**
 * Request parameters for importSnapshot operation in MockApi.
 * @export
 * @interface MockApiImportSnapshotRequest
 */
export interface MockApiImportSnapshotRequest {
    /**
     * The repository snapshot file
     * @type {File}
     * @memberof MockApiImportSnapshot
     */
    readonly file: File
}

/**
 * Request parameters for overrideServiceOperation operation in MockApi.
 * @export
 * @interface MockApiOverrideServiceOperationRequest
 */
export interface MockApiOverrideServiceOperationRequest {
    /**
     * Unique identifier of Service to managed
     * @type {string}
     * @memberof MockApiOverrideServiceOperation
     */
    readonly id: string

    /**
     * Name of operation to update
     * @type {string}
     * @memberof MockApiOverrideServiceOperation
     */
    readonly operationName: string

    /**
     * 
     * @type {OperationOverrideDTO}
     * @memberof MockApiOverrideServiceOperation
     */
    readonly operationOverrideDTO: OperationOverrideDTO
}

/**
 * Request parameters for searchServices operation in MockApi.
 * @export
 * @interface MockApiSearchServicesRequest
 */
export interface MockApiSearchServicesRequest {
    /**
     * Map of criterion. Key can be simply \&#39;name\&#39; with value as the searched string. You can also search by label using keys like \&#39;labels.x\&#39; where \&#39;x\&#39; is the label and value the label value
     * @type {{ [key: string]: string; }}
     * @memberof MockApiSearchServices
     */
    readonly queryMap: { [key: string]: string; }
}

/**
 * Request parameters for updateServiceMetadata operation in MockApi.
 * @export
 * @interface MockApiUpdateServiceMetadataRequest
 */
export interface MockApiUpdateServiceMetadataRequest {
    /**
     * Unique identifier of Service to managed
     * @type {string}
     * @memberof MockApiUpdateServiceMetadata
     */
    readonly id: string

    /**
     * 
     * @type {Metadata}
     * @memberof MockApiUpdateServiceMetadata
     */
    readonly metadata: Metadata
}

/**
 * MockApi - object-oriented interface
 * @export
 * @class MockApi
 * @extends {BaseAPI}
 */
export class MockApi extends BaseAPI {
    /**
     * Delete a Service
     * @summary Delete Service
     * @param {MockApiDeleteServiceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MockApi
     */
    public deleteService(requestParameters: MockApiDeleteServiceRequest, options?: RawAxiosRequestConfig) {
        return MockApiFp(this.configuration).deleteService(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export a repostiory snapshot with requested services
     * @summary Export a snapshot
     * @param {MockApiExportSnapshotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MockApi
     */
    public exportSnapshot(requestParameters: MockApiExportSnapshotRequest, options?: RawAxiosRequestConfig) {
        return MockApiFp(this.configuration).exportSnapshot(requestParameters.serviceIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Service
     * @param {MockApiGetServiceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MockApi
     */
    public getService(requestParameters: MockApiGetServiceRequest, options?: RawAxiosRequestConfig) {
        return MockApiFp(this.configuration).getService(requestParameters.id, requestParameters.messages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Services and APIs
     * @param {MockApiGetServicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MockApi
     */
    public getServices(requestParameters: MockApiGetServicesRequest = {}, options?: RawAxiosRequestConfig) {
        return MockApiFp(this.configuration).getServices(requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Services counter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MockApi
     */
    public getServicesCounter(options?: RawAxiosRequestConfig) {
        return MockApiFp(this.configuration).getServicesCounter(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the already used labels for Services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MockApi
     */
    public getServicesLabels(options?: RawAxiosRequestConfig) {
        return MockApiFp(this.configuration).getServicesLabels(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import a repository snapshot previsouly exported into Microcks
     * @summary Import a snapshot
     * @param {MockApiImportSnapshotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MockApi
     */
    public importSnapshot(requestParameters: MockApiImportSnapshotRequest, options?: RawAxiosRequestConfig) {
        return MockApiFp(this.configuration).importSnapshot(requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Override Service Operation
     * @param {MockApiOverrideServiceOperationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MockApi
     */
    public overrideServiceOperation(requestParameters: MockApiOverrideServiceOperationRequest, options?: RawAxiosRequestConfig) {
        return MockApiFp(this.configuration).overrideServiceOperation(requestParameters.id, requestParameters.operationName, requestParameters.operationOverrideDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for Services and APIs
     * @param {MockApiSearchServicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MockApi
     */
    public searchServices(requestParameters: MockApiSearchServicesRequest, options?: RawAxiosRequestConfig) {
        return MockApiFp(this.configuration).searchServices(requestParameters.queryMap, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Service Metadata
     * @param {MockApiUpdateServiceMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MockApi
     */
    public updateServiceMetadata(requestParameters: MockApiUpdateServiceMetadataRequest, options?: RawAxiosRequestConfig) {
        return MockApiFp(this.configuration).updateServiceMetadata(requestParameters.id, requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestApi - axios parameter creator
 * @export
 */
export const TestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Test
         * @param {TestRequest} testRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTest: async (testRequest: TestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testRequest' is not null or undefined
            assertParamExists('createTest', 'testRequest', testRequest)
            const localVarPath = `/tests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get events for TestCase
         * @param {string} id Unique identifier of TestResult to manage
         * @param {string} testCaseId Unique identifier of TetsCaseResult to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByTestCase: async (id: string, testCaseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEventsByTestCase', 'id', id)
            // verify required parameter 'testCaseId' is not null or undefined
            assertParamExists('getEventsByTestCase', 'testCaseId', testCaseId)
            const localVarPath = `/tests/{id}/events/{testCaseId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"testCaseId"}}`, encodeURIComponent(String(testCaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get messages for TestCase
         * @param {string} id Unique identifier of TestResult to manage
         * @param {string} testCaseId Unique identifier of TetsCaseResult to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesByTestCase: async (id: string, testCaseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMessagesByTestCase', 'id', id)
            // verify required parameter 'testCaseId' is not null or undefined
            assertParamExists('getMessagesByTestCase', 'testCaseId', testCaseId)
            const localVarPath = `/tests/{id}/messages/{testCaseId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"testCaseId"}}`, encodeURIComponent(String(testCaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get TestResult
         * @param {string} id Unique identifier of TestResult to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestResult: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTestResult', 'id', id)
            const localVarPath = `/tests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get TestResults by Service
         * @param {string} serviceId Unique identifier of Service to manage TestResults for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestResultsByService: async (serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getTestResultsByService', 'serviceId', serviceId)
            const localVarPath = `/tests/service/{serviceId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the TestResults for Service counter
         * @param {string} serviceId Unique identifier of Service to manage TestResults for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestResultsByServiceCounter: async (serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getTestResultsByServiceCounter', 'serviceId', serviceId)
            const localVarPath = `/tests/service/{serviceId}/count`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Report a TestCaseResult (typically used by a Test runner)
         * @summary Report and create a new TestCaseResult
         * @param {string} id Unique identifier of TestResult to manage
         * @param {TestCaseReturnDTO} testCaseReturnDTO TestCase return wrapper object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTestCaseResult: async (id: string, testCaseReturnDTO: TestCaseReturnDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reportTestCaseResult', 'id', id)
            // verify required parameter 'testCaseReturnDTO' is not null or undefined
            assertParamExists('reportTestCaseResult', 'testCaseReturnDTO', testCaseReturnDTO)
            const localVarPath = `/tests/{id}/testCaseResult`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt-bearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "jwt-bearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testCaseReturnDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestApi - functional programming interface
 * @export
 */
export const TestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Test
         * @param {TestRequest} testRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTest(testRequest: TestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTest(testRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.createTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get events for TestCase
         * @param {string} id Unique identifier of TestResult to manage
         * @param {string} testCaseId Unique identifier of TetsCaseResult to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsByTestCase(id: string, testCaseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UnidirectionalEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsByTestCase(id, testCaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.getEventsByTestCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get messages for TestCase
         * @param {string} id Unique identifier of TestResult to manage
         * @param {string} testCaseId Unique identifier of TetsCaseResult to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesByTestCase(id: string, testCaseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestResponsePair>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesByTestCase(id, testCaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.getMessagesByTestCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get TestResult
         * @param {string} id Unique identifier of TestResult to manage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestResult(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestResult(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.getTestResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get TestResults by Service
         * @param {string} serviceId Unique identifier of Service to manage TestResults for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestResultsByService(serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestResultsByService(serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.getTestResultsByService']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the TestResults for Service counter
         * @param {string} serviceId Unique identifier of Service to manage TestResults for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestResultsByServiceCounter(serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Counter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestResultsByServiceCounter(serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.getTestResultsByServiceCounter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Report a TestCaseResult (typically used by a Test runner)
         * @summary Report and create a new TestCaseResult
         * @param {string} id Unique identifier of TestResult to manage
         * @param {TestCaseReturnDTO} testCaseReturnDTO TestCase return wrapper object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportTestCaseResult(id: string, testCaseReturnDTO: TestCaseReturnDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestCaseResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportTestCaseResult(id, testCaseReturnDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.reportTestCaseResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestApi - factory interface
 * @export
 */
export const TestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Test
         * @param {TestApiCreateTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTest(requestParameters: TestApiCreateTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<TestResult> {
            return localVarFp.createTest(requestParameters.testRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get events for TestCase
         * @param {TestApiGetEventsByTestCaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByTestCase(requestParameters: TestApiGetEventsByTestCaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UnidirectionalEvent>> {
            return localVarFp.getEventsByTestCase(requestParameters.id, requestParameters.testCaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get messages for TestCase
         * @param {TestApiGetMessagesByTestCaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesByTestCase(requestParameters: TestApiGetMessagesByTestCaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<RequestResponsePair>> {
            return localVarFp.getMessagesByTestCase(requestParameters.id, requestParameters.testCaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get TestResult
         * @param {TestApiGetTestResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestResult(requestParameters: TestApiGetTestResultRequest, options?: RawAxiosRequestConfig): AxiosPromise<TestResult> {
            return localVarFp.getTestResult(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get TestResults by Service
         * @param {TestApiGetTestResultsByServiceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestResultsByService(requestParameters: TestApiGetTestResultsByServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TestResult>> {
            return localVarFp.getTestResultsByService(requestParameters.serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the TestResults for Service counter
         * @param {TestApiGetTestResultsByServiceCounterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestResultsByServiceCounter(requestParameters: TestApiGetTestResultsByServiceCounterRequest, options?: RawAxiosRequestConfig): AxiosPromise<Counter> {
            return localVarFp.getTestResultsByServiceCounter(requestParameters.serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Report a TestCaseResult (typically used by a Test runner)
         * @summary Report and create a new TestCaseResult
         * @param {TestApiReportTestCaseResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTestCaseResult(requestParameters: TestApiReportTestCaseResultRequest, options?: RawAxiosRequestConfig): AxiosPromise<TestCaseResult> {
            return localVarFp.reportTestCaseResult(requestParameters.id, requestParameters.testCaseReturnDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTest operation in TestApi.
 * @export
 * @interface TestApiCreateTestRequest
 */
export interface TestApiCreateTestRequest {
    /**
     * 
     * @type {TestRequest}
     * @memberof TestApiCreateTest
     */
    readonly testRequest: TestRequest
}

/**
 * Request parameters for getEventsByTestCase operation in TestApi.
 * @export
 * @interface TestApiGetEventsByTestCaseRequest
 */
export interface TestApiGetEventsByTestCaseRequest {
    /**
     * Unique identifier of TestResult to manage
     * @type {string}
     * @memberof TestApiGetEventsByTestCase
     */
    readonly id: string

    /**
     * Unique identifier of TetsCaseResult to manage
     * @type {string}
     * @memberof TestApiGetEventsByTestCase
     */
    readonly testCaseId: string
}

/**
 * Request parameters for getMessagesByTestCase operation in TestApi.
 * @export
 * @interface TestApiGetMessagesByTestCaseRequest
 */
export interface TestApiGetMessagesByTestCaseRequest {
    /**
     * Unique identifier of TestResult to manage
     * @type {string}
     * @memberof TestApiGetMessagesByTestCase
     */
    readonly id: string

    /**
     * Unique identifier of TetsCaseResult to manage
     * @type {string}
     * @memberof TestApiGetMessagesByTestCase
     */
    readonly testCaseId: string
}

/**
 * Request parameters for getTestResult operation in TestApi.
 * @export
 * @interface TestApiGetTestResultRequest
 */
export interface TestApiGetTestResultRequest {
    /**
     * Unique identifier of TestResult to manage
     * @type {string}
     * @memberof TestApiGetTestResult
     */
    readonly id: string
}

/**
 * Request parameters for getTestResultsByService operation in TestApi.
 * @export
 * @interface TestApiGetTestResultsByServiceRequest
 */
export interface TestApiGetTestResultsByServiceRequest {
    /**
     * Unique identifier of Service to manage TestResults for
     * @type {string}
     * @memberof TestApiGetTestResultsByService
     */
    readonly serviceId: string
}

/**
 * Request parameters for getTestResultsByServiceCounter operation in TestApi.
 * @export
 * @interface TestApiGetTestResultsByServiceCounterRequest
 */
export interface TestApiGetTestResultsByServiceCounterRequest {
    /**
     * Unique identifier of Service to manage TestResults for
     * @type {string}
     * @memberof TestApiGetTestResultsByServiceCounter
     */
    readonly serviceId: string
}

/**
 * Request parameters for reportTestCaseResult operation in TestApi.
 * @export
 * @interface TestApiReportTestCaseResultRequest
 */
export interface TestApiReportTestCaseResultRequest {
    /**
     * Unique identifier of TestResult to manage
     * @type {string}
     * @memberof TestApiReportTestCaseResult
     */
    readonly id: string

    /**
     * TestCase return wrapper object
     * @type {TestCaseReturnDTO}
     * @memberof TestApiReportTestCaseResult
     */
    readonly testCaseReturnDTO: TestCaseReturnDTO
}

/**
 * TestApi - object-oriented interface
 * @export
 * @class TestApi
 * @extends {BaseAPI}
 */
export class TestApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Test
     * @param {TestApiCreateTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public createTest(requestParameters: TestApiCreateTestRequest, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).createTest(requestParameters.testRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get events for TestCase
     * @param {TestApiGetEventsByTestCaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public getEventsByTestCase(requestParameters: TestApiGetEventsByTestCaseRequest, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).getEventsByTestCase(requestParameters.id, requestParameters.testCaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get messages for TestCase
     * @param {TestApiGetMessagesByTestCaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public getMessagesByTestCase(requestParameters: TestApiGetMessagesByTestCaseRequest, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).getMessagesByTestCase(requestParameters.id, requestParameters.testCaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get TestResult
     * @param {TestApiGetTestResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public getTestResult(requestParameters: TestApiGetTestResultRequest, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).getTestResult(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get TestResults by Service
     * @param {TestApiGetTestResultsByServiceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public getTestResultsByService(requestParameters: TestApiGetTestResultsByServiceRequest, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).getTestResultsByService(requestParameters.serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the TestResults for Service counter
     * @param {TestApiGetTestResultsByServiceCounterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public getTestResultsByServiceCounter(requestParameters: TestApiGetTestResultsByServiceCounterRequest, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).getTestResultsByServiceCounter(requestParameters.serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Report a TestCaseResult (typically used by a Test runner)
     * @summary Report and create a new TestCaseResult
     * @param {TestApiReportTestCaseResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public reportTestCaseResult(requestParameters: TestApiReportTestCaseResultRequest, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).reportTestCaseResult(requestParameters.id, requestParameters.testCaseReturnDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



